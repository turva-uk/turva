set shell := ["bash", "-c"]

default:
    just --list

initialise:= 'set -euxo pipefail
    initialise() {
        # Clear the terminal window title on exit
        echo -ne "\033]0; \007"
    }
    trap initialise EXIT
    just _terminal-description'


_terminal-description message=" ":
    echo -ne "\033]0;{{message}}\007"

alias aj := abbreviate-just
# Set up the description for terminal windows
abbreviate-just:
    #!/usr/bin/env bash
    {{initialise}} abbreviate-just
    alias_definition="alias j='just'"

    if grep -Fxq "$alias_definition" ~/.zshrc
    then
        echo "Alias already exists in ~/.zshrc"
    else
        echo "$alias_definition" >> ~/.zshrc
        echo "Alias added to ~/.zshrc"
    fi

    echo "Please run the following command to apply the changes to this terminal:"
    echo "source ~/.zshrc"


alias c := clean
# Clean up all containers, volumes, and cached images
clean:
    #!/usr/bin/env bash
    {{initialise}} "clean"
    docker compose down -v
    docker compose rm -fsv
    docker system prune -f


alias dd := dev-down
# Stop the containers
dev-down:
    #!/usr/bin/env bash
    {{initialise}} "stop"
    docker compose -f docker-compose.yml down


alias d := docs
# Start the MkDocs documentation server on port 8001 with hot reload
docs:
    #!/usr/bin/env bash
    {{initialise}} "docs"
    echo "Starting MkDocs documentation server with hot reload..."
    echo -e "\033[34mYou need to restart if you want to built the typeScript docs again.\033[0m"
    cd frontend && yarn docs:build
    echo "Documentation will be available at http://localhost:8001"
    cd ../docs && mkdocs serve -a localhost:8001


alias l := logs
# Follow logs for all services or a specific service (e.g., 'j l api')
logs service="":
    #!/usr/bin/env bash
    {{initialise}} "logs"
    docker compose logs -f {{service}}


alias pc := pre-commit
# Run pre-commit checks on all files
pre-commit:
    #!/usr/bin/env bash
    {{initialise}} "pre-commit"
    pre-commit run --all-files


alias sg := semgrep
# Run semgrep security checks on frontend code
semgrep:
    #!/usr/bin/env bash
    {{initialise}} "semgrep"
    cd frontend && semgrep --config .semgrep.yml --error


alias sd := start-dev
# Start the dev app (build: 'b' will also build the images)
start-dev build="":
    #!/usr/bin/env bash
    {{initialise}} "start-dev"

    if [ "{{build}}" = "b" ]; then \
        docker compose -f docker-compose.yml up --build; \
    else \
        docker compose -f docker-compose.yml up; \
    fi


alias rb := remove-branches
# Remove all local branches that have been merged into main
remove-branches:
    #!/usr/bin/env bash
    {{initialise}} "remove-branches"
    git fetch -p && git branch -vv | awk '/: gone]/{print $1}' | xargs git branch -d


alias r := restart
# Restart all services or a specific service (e.g., 'j r frontend')
restart service="":
    #!/usr/bin/env bash
    {{initialise}} "restart"
    docker compose restart {{service}}


alias pt := python-test
# Run Python unit tests in the API container
python-test:
    #!/usr/bin/env bash
    {{initialise}} "python-test"
    docker compose exec api pytest /app/src/tests/unit -v


alias ti := test-integration
# Run Python integration tests in the API container
test-integration:
    #!/usr/bin/env bash
    {{initialise}} "test-integration"
    docker compose exec api pytest /app/src/tests/integration -v


alias ta := test-all
# Run all Python tests (unit + integration) in the API container
test-all:
    #!/usr/bin/env bash
    {{initialise}} "test-all"
    docker compose exec api pytest /app/src -v


alias tc := test-coverage
# Run all tests with coverage report
test-coverage:
    #!/usr/bin/env bash
    {{initialise}} "test-coverage"
    docker compose exec api coverage run -m pytest /app/src --cov-config=/app/pyproject.toml
    docker compose exec api coverage html
    echo "Coverage report generated in api/src/htmlcov/index.html"
